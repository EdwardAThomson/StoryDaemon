"""Writer context builder for scene prose generation."""

from typing import Dict, Any, List, Optional
from pathlib import Path


class WriterContextBuilder:
    """Builds context for the scene writer LLM."""
    
    def __init__(self, memory_manager, vector_store, config):
        """Initialize writer context builder.
        
        Args:
            memory_manager: MemoryManager instance
            vector_store: VectorStore instance
            config: Configuration object
        """
        self.memory = memory_manager
        self.vector = vector_store
        self.config = config
    
    def build_writer_context(
        self,
        plan: Dict[str, Any],
        execution_results: Dict[str, Any],
        project_state: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Build context dictionary for writer prompt.
        
        Args:
            plan: The plan generated by planner
            execution_results: Results from plan execution
            project_state: Current project state
        
        Returns:
            Dictionary with all context variables for writer prompt
        """
        # Extract basic info
        novel_name = project_state.get("novel_name", "Untitled Novel")
        current_tick = project_state.get("current_tick", 0)
        scene_intention = plan.get("scene_intention", "Continue the story")
        key_change = plan.get("key_change", "Advance the plot")
        progress_milestone = plan.get("progress_milestone", "")
        progress_step = plan.get("progress_step", "")
        pov_character_id = plan.get("pov_character", "")
        location_id = plan.get("target_location")
        scene_mode = plan.get("scene_mode", "")
        palette_shift = plan.get("palette_shift", "")
        transition_path = plan.get("transition_path", "")
        dialogue_targets = plan.get("dialogue_targets", "")
        
        # Get POV character details
        pov_character_name, pov_character_details = self._get_character_details(
            pov_character_id
        )
        
        # Get location details
        location_name, location_details = self._get_location_details(location_id)
        
        # Format recent context with full text for immediate scenes
        full_text_count = self.config.get('generation.full_text_scenes_count', 2)
        summary_count = self.config.get('generation.summary_scenes_count', 3)
        recent_context = self._format_recent_context(
            full_text_count=full_text_count,
            summary_count=summary_count
        )
        
        # Format tool results
        tool_results_summary = self._format_tool_results(execution_results)
        
        # Get optional length guidance from plan metadata
        scene_length_guidance = self._get_length_guidance(plan)
        
        return {
            "novel_name": novel_name,
            "current_tick": current_tick,
            "scene_intention": scene_intention,
            "key_change": key_change,
            "progress_milestone": progress_milestone,
            "progress_step": progress_step,
            "scene_mode": scene_mode,
            "palette_shift": palette_shift,
            "transition_path": transition_path,
            "dialogue_targets": dialogue_targets,
            "pov_character_id": pov_character_id,
            "pov_character_name": pov_character_name,
            "pov_character_details": pov_character_details,
            "location_id": location_id,
            "location_name": location_name,
            "location_details": location_details,
            "recent_context": recent_context,
            "tool_results_summary": tool_results_summary,
            "scene_length_guidance": scene_length_guidance
        }
    
    def _get_character_details(self, character_id: str) -> tuple[str, str]:
        """Get character name and formatted details.
        
        Args:
            character_id: Character ID
        
        Returns:
            Tuple of (character_name, formatted_details)
        """
        if not character_id:
            return "Unknown", "No POV character specified."
        
        character = self.memory.load_character(character_id)
        if not character:
            return character_id, f"Character {character_id} not found."
        
        # Format character details
        details = f"**Name:** {character.display_name} (full name: {character.full_name})\n"
        details += f"**ID:** {character.id}\n\n"
        
        if character.description:
            details += f"**Description:** {character.description}\n\n"
        
        if character.personality and character.personality.core_traits:
            details += f"**Personality:** {', '.join(character.personality.core_traits)}\n\n"
        
        if character.backstory:
            details += f"**Backstory:** {character.backstory}\n\n"
        
        if character.current_state.goals:
            details += f"**Goals:** {', '.join(character.current_state.goals)}\n\n"
        
        return character.display_name, details.strip()
    
    def _get_location_details(self, location_id: Optional[str]) -> tuple[str, str]:
        """Get location name and formatted details.
        
        Args:
            location_id: Location ID or None
        
        Returns:
            Tuple of (location_name, formatted_details)
        """
        if not location_id:
            return "Unknown Location", "Location to be determined during scene."
        
        location = self.memory.load_location(location_id)
        if not location:
            return location_id, f"Location {location_id} not found."
        
        # Format location details
        details = f"**Name:** {location.name}\n"
        details += f"**ID:** {location.id}\n\n"
        
        if location.description:
            details += f"**Description:** {location.description}\n\n"
        
        if location.type:
            details += f"**Type:** {location.type}\n\n"
        
        if location.atmosphere:
            details += f"**Atmosphere:** {location.atmosphere}\n\n"
        
        if location.features:
            details += f"**Features:** {', '.join(location.features)}\n\n"
        
        return location.name, details.strip()
    
    def _format_recent_context(self, full_text_count: int = 2, summary_count: int = 3) -> str:
        """Format recent context with full text for immediate scenes.
        
        Args:
            full_text_count: Number of recent scenes to include as full text
            summary_count: Number of older scenes to include as summaries
        
        Returns:
            Formatted context with full text + summaries
        """
        # Get all scene IDs
        scene_ids = self.memory.list_scenes()
        
        if not scene_ids:
            return "This is the first scene of the novel."
        
        context_parts = []
        
        # Calculate which scenes get full text vs summaries
        total_scenes = len(scene_ids)
        
        # Get scenes for summaries (older scenes)
        summary_start = max(0, total_scenes - full_text_count - summary_count)
        summary_end = max(0, total_scenes - full_text_count)
        summary_ids = scene_ids[summary_start:summary_end] if summary_end > summary_start else []
        
        # Get scenes for full text (most recent)
        full_text_ids = scene_ids[-full_text_count:] if total_scenes >= full_text_count else scene_ids
        
        # Add summary scenes first (if any)
        if summary_ids:
            context_parts.append("## Earlier Scenes (Summaries)\n")
            for scene_id in summary_ids:
                scene = self.memory.load_scene(scene_id)
                if scene:
                    context_parts.append(f"**Scene {scene.tick}: {scene.title}**")
                    if scene.summary:
                        # Format summary bullets
                        if isinstance(scene.summary, list):
                            for bullet in scene.summary:
                                context_parts.append(f"- {bullet}")
                        else:
                            context_parts.append(scene.summary)
                    context_parts.append("")  # Blank line
            context_parts.append("")  # Extra blank line between sections
        
        # Add full text scenes (most recent)
        if full_text_ids:
            context_parts.append("## Recent Scenes (Full Text)\n")
            for scene_id in full_text_ids:
                scene = self.memory.load_scene(scene_id)
                if scene:
                    # Load the actual scene markdown file
                    # Scene IDs are like "S000", "S001", etc.
                    scene_number = scene_id[1:]  # Remove 'S' prefix
                    scene_file = self.memory.project_path / "scenes" / f"scene_{scene_number}.md"
                    
                    if scene_file.exists():
                        scene_text = scene_file.read_text(encoding='utf-8')
                        context_parts.append(f"**Scene {scene.tick}: {scene.title}**\n")
                        context_parts.append(scene_text.strip())
                        context_parts.append("\n---\n")
                    else:
                        # Fallback to summary if file doesn't exist
                        context_parts.append(f"**Scene {scene.tick}: {scene.title}**")
                        if scene.summary:
                            if isinstance(scene.summary, list):
                                for bullet in scene.summary:
                                    context_parts.append(f"- {bullet}")
                            else:
                                context_parts.append(scene.summary)
                        context_parts.append("")
        
        if not context_parts:
            return "This is the first scene of the novel."
        
        return "\n".join(context_parts).strip()
    
    def _format_tool_results(self, execution_results: Dict[str, Any]) -> str:
        """Format tool execution results into readable summary.
        
        Args:
            execution_results: Results from plan execution
        
        Returns:
            Formatted string summarizing tool results
        """
        if not execution_results:
            return "No tools were executed for this scene."
        
        actions_executed = execution_results.get("actions_executed", [])
        
        if not actions_executed:
            return "No tools were executed for this scene."
        
        summary_parts = []
        
        for action in actions_executed:
            tool_name = action.get("tool", "unknown")
            result = action.get("result", {})
            
            # Format based on tool type
            if tool_name == "memory.search":
                query = action.get("args", {}).get("query", "")
                results = result.get("results", [])
                summary_parts.append(f"- Searched memory for '{query}': Found {len(results)} results")
            
            elif tool_name == "character.generate":
                char_name = result.get("name", "Unknown")
                summary_parts.append(f"- Generated new character: {char_name}")
            
            elif tool_name == "location.generate":
                loc_name = result.get("name", "Unknown")
                summary_parts.append(f"- Generated new location: {loc_name}")
            
            elif tool_name == "relationship.create":
                summary_parts.append(f"- Created new relationship")
            
            elif tool_name == "relationship.update":
                summary_parts.append(f"- Updated relationship")
            
            else:
                summary_parts.append(f"- Executed {tool_name}")
        
        if not summary_parts:
            return "No significant tool results to report."
        
        return "\n".join(summary_parts)
    
    def _get_length_guidance(self, plan: Dict[str, Any]) -> str:
        """Get optional length guidance from plan.
        
        Args:
            plan: The plan dictionary
        
        Returns:
            Formatted length guidance string (may be empty)
        """
        # Check if plan has scene_length metadata
        metadata = plan.get("metadata", {})
        scene_length = metadata.get("scene_length", "").lower()
        
        if scene_length == "brief":
            return "\n\n**Length Guidance:** Keep this scene brief and focused - a quick moment or transition."
        elif scene_length == "short":
            return "\n\n**Length Guidance:** Write a short scene - establish the key moment without extensive detail."
        elif scene_length == "long":
            return "\n\n**Length Guidance:** Take your time with this scene - develop it fully with rich detail and depth."
        elif scene_length == "extended":
            return "\n\n**Length Guidance:** This is a major scene - write extensively, exploring all nuances and implications."
        else:
            # No guidance - let the scene be whatever length it needs
            return ""
