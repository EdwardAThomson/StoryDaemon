"""Writer context builder for scene prose generation."""

from typing import Dict, Any, List, Optional
from pathlib import Path


class WriterContextBuilder:
    """Builds context for the scene writer LLM."""
    
    def __init__(self, memory_manager, vector_store, config):
        """Initialize writer context builder.
        
        Args:
            memory_manager: MemoryManager instance
            vector_store: VectorStore instance
            config: Configuration object
        """
        self.memory = memory_manager
        self.vector = vector_store
        self.config = config
    
    def build_writer_context(
        self,
        plan: Dict[str, Any],
        execution_results: Dict[str, Any],
        project_state: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Build context dictionary for writer prompt.
        
        Args:
            plan: The plan generated by planner
            execution_results: Results from plan execution
            project_state: Current project state
        
        Returns:
            Dictionary with all context variables for writer prompt
        """
        # Extract basic info
        novel_name = project_state.get("novel_name", "Untitled Novel")
        current_tick = project_state.get("current_tick", 0)
        scene_intention = plan.get("scene_intention", "Continue the story")
        pov_character_id = plan.get("pov_character", "")
        location_id = plan.get("target_location")
        
        # Get POV character details
        pov_character_name, pov_character_details = self._get_character_details(
            pov_character_id
        )
        
        # Get location details
        location_name, location_details = self._get_location_details(location_id)
        
        # Format recent context
        recent_context = self._format_recent_context(count=2)
        
        # Format tool results
        tool_results_summary = self._format_tool_results(execution_results)
        
        # Get word count targets from config
        target_word_count_min = self.config.get('generation.target_word_count_min', 500)
        target_word_count_max = self.config.get('generation.target_word_count_max', 900)
        
        return {
            "novel_name": novel_name,
            "current_tick": current_tick,
            "scene_intention": scene_intention,
            "pov_character_name": pov_character_name,
            "pov_character_details": pov_character_details,
            "location_name": location_name,
            "location_details": location_details,
            "recent_context": recent_context,
            "tool_results_summary": tool_results_summary,
            "target_word_count_min": target_word_count_min,
            "target_word_count_max": target_word_count_max
        }
    
    def _get_character_details(self, character_id: str) -> tuple[str, str]:
        """Get character name and formatted details.
        
        Args:
            character_id: Character ID
        
        Returns:
            Tuple of (character_name, formatted_details)
        """
        if not character_id:
            return "Unknown", "No POV character specified."
        
        character = self.memory.load_character(character_id)
        if not character:
            return character_id, f"Character {character_id} not found."
        
        # Format character details
        details = f"**Name:** {character.name}\n"
        details += f"**ID:** {character.id}\n\n"
        
        if character.description:
            details += f"**Description:** {character.description}\n\n"
        
        if character.personality:
            details += f"**Personality:** {character.personality}\n\n"
        
        if character.background:
            details += f"**Background:** {character.background}\n\n"
        
        if character.goals:
            details += f"**Goals:** {', '.join(character.goals)}\n\n"
        
        if character.traits:
            details += f"**Traits:** {', '.join(character.traits)}\n\n"
        
        return character.name, details.strip()
    
    def _get_location_details(self, location_id: Optional[str]) -> tuple[str, str]:
        """Get location name and formatted details.
        
        Args:
            location_id: Location ID or None
        
        Returns:
            Tuple of (location_name, formatted_details)
        """
        if not location_id:
            return "Unknown Location", "Location to be determined during scene."
        
        location = self.memory.load_location(location_id)
        if not location:
            return location_id, f"Location {location_id} not found."
        
        # Format location details
        details = f"**Name:** {location.name}\n"
        details += f"**ID:** {location.id}\n\n"
        
        if location.description:
            details += f"**Description:** {location.description}\n\n"
        
        if location.type:
            details += f"**Type:** {location.type}\n\n"
        
        if location.atmosphere:
            details += f"**Atmosphere:** {location.atmosphere}\n\n"
        
        if location.features:
            details += f"**Features:** {', '.join(location.features)}\n\n"
        
        return location.name, details.strip()
    
    def _format_recent_context(self, count: int = 2) -> str:
        """Format recent scene summaries for context.
        
        Args:
            count: Number of recent scenes to include
        
        Returns:
            Formatted string of recent scenes
        """
        # Get all scene IDs
        scene_ids = self.memory.list_scenes()
        
        if not scene_ids:
            return "This is the first scene of the novel."
        
        # Get last N scenes
        recent_ids = scene_ids[-count:] if len(scene_ids) >= count else scene_ids
        
        context_parts = []
        for scene_id in recent_ids:
            scene = self.memory.load_scene(scene_id)
            if scene:
                context_parts.append(f"**Scene {scene.tick}: {scene.title}**")
                if scene.summary:
                    # Format summary bullets
                    if isinstance(scene.summary, list):
                        for bullet in scene.summary:
                            context_parts.append(f"- {bullet}")
                    else:
                        context_parts.append(scene.summary)
                context_parts.append("")  # Blank line
        
        if not context_parts:
            return "This is the first scene of the novel."
        
        return "\n".join(context_parts).strip()
    
    def _format_tool_results(self, execution_results: Dict[str, Any]) -> str:
        """Format tool execution results into readable summary.
        
        Args:
            execution_results: Results from plan execution
        
        Returns:
            Formatted string summarizing tool results
        """
        if not execution_results:
            return "No tools were executed for this scene."
        
        actions_executed = execution_results.get("actions_executed", [])
        
        if not actions_executed:
            return "No tools were executed for this scene."
        
        summary_parts = []
        
        for action in actions_executed:
            tool_name = action.get("tool", "unknown")
            result = action.get("result", {})
            
            # Format based on tool type
            if tool_name == "memory.search":
                query = action.get("args", {}).get("query", "")
                results = result.get("results", [])
                summary_parts.append(f"- Searched memory for '{query}': Found {len(results)} results")
            
            elif tool_name == "character.generate":
                char_name = result.get("name", "Unknown")
                summary_parts.append(f"- Generated new character: {char_name}")
            
            elif tool_name == "location.generate":
                loc_name = result.get("name", "Unknown")
                summary_parts.append(f"- Generated new location: {loc_name}")
            
            elif tool_name == "relationship.create":
                summary_parts.append(f"- Created new relationship")
            
            elif tool_name == "relationship.update":
                summary_parts.append(f"- Updated relationship")
            
            else:
                summary_parts.append(f"- Executed {tool_name}")
        
        if not summary_parts:
            return "No significant tool results to report."
        
        return "\n".join(summary_parts)
