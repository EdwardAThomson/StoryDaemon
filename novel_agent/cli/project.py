"""Novel project management.

Handles creation and discovery of novel working directories.
"""
import os
import uuid
import yaml
from datetime import datetime
from typing import Optional, TYPE_CHECKING
from ..utils.file_ops import write_json, write_file, read_json
from ..configs.config import Config

if TYPE_CHECKING:
    from .foundation import StoryFoundation


def create_novel_project(
    name: str, 
    base_dir: Optional[str] = None,
    foundation: Optional["StoryFoundation"] = None
) -> str:
    """Create a new novel project directory structure.
    
    Args:
        name: Name of the novel
        base_dir: Base directory (default: ~/novels from config)
        foundation: Optional story foundation (genre, premise, etc.)
        
    Returns:
        Path to created project directory
        
    Raises:
        ValueError: If project already exists
        IOError: If directories cannot be created
    """
    config = Config()
    
    if base_dir is None:
        base_dir = config.get('paths.novels_dir')
    
    # Expand user path
    base_dir = os.path.expanduser(base_dir)
    
    # Generate unique project ID to prevent overwrites
    project_id = str(uuid.uuid4())[:8]  # Use first 8 chars for readability
    project_dirname = f"{name}_{project_id}"
    project_dir = os.path.join(base_dir, project_dirname)
    
    # This should never happen with UUID, but check anyway
    if os.path.exists(project_dir):
        raise ValueError(f"Project already exists: {project_dir}")
    
    try:
        # Create directory structure
        os.makedirs(os.path.join(project_dir, 'memory', 'characters'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'memory', 'locations'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'memory', 'scenes'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'memory', 'index'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'scenes'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'plans'), exist_ok=True)
        os.makedirs(os.path.join(project_dir, 'errors'), exist_ok=True)
        
        # Create initial state file
        initial_state = {
            'novel_name': name,
            'project_id': project_id,
            'current_tick': 0,
            'active_character': None,
            'created_at': datetime.now().isoformat(),
            'last_updated': datetime.now().isoformat(),
        }
        
        # Add story foundation if provided
        if foundation:
            initial_state['story_foundation'] = foundation.to_dict()
        
        # Add story goals structure (Phase 7A.2)
        primary_goal = None
        if foundation and foundation.primary_goal:
            # User specified a primary goal in foundation
            primary_goal = {
                'description': foundation.primary_goal,
                'source': 'user_specified',
                'promoted_at_tick': 0
            }
        
        initial_state['story_goals'] = {
            'primary': primary_goal,  # User-specified or auto-promotes during ticks 10-15
            'secondary': [],
            'promotion_candidates': [],
            'promotion_tick': 0 if primary_goal else None
        }
        
        write_json(os.path.join(project_dir, 'state.json'), initial_state)
        
        # Create initial config
        novel_config = {
            'llm': {
                'planner_max_tokens': config.get('llm.planner_max_tokens'),
                'writer_max_tokens': config.get('llm.writer_max_tokens'),
            },
            'generation': {
                'target_word_count_min': config.get('generation.target_word_count_min'),
                'target_word_count_max': config.get('generation.target_word_count_max'),
            }
        }
        
        config_path = os.path.join(project_dir, 'config.yaml')
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(novel_config, f, default_flow_style=False, sort_keys=False)
        
        # Create README
        readme = f"""# {name}

Generated by StoryDaemon

## Project Structure

- `memory/` - Story memory (characters, locations, scenes)
- `scenes/` - Generated scene markdown files
- `plans/` - Planning JSON files for each tick
- `errors/` - Error logs when ticks fail
- `state.json` - Current story state
- `config.yaml` - Project-specific configuration

## Commands

Run from this directory:

```bash
novel tick              # Generate next scene
novel run --n 5         # Generate 5 scenes
novel summarize         # Compile all scenes
```

Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        write_file(os.path.join(project_dir, 'README.md'), readme)
        
        # Create empty open_loops.json
        write_json(os.path.join(project_dir, 'memory', 'open_loops.json'), {
            'loops': []
        })
        
        # Create empty relationships.json
        write_json(os.path.join(project_dir, 'memory', 'relationships.json'), {
            'relationships': []
        })
        
        # Create counters.json
        write_json(os.path.join(project_dir, 'memory', 'counters.json'), {
            'character': 0,
            'location': 0,
            'scene': 0,
            'open_loop': 0,
            'relationship': 0
        })
        
        return project_dir
    
    except Exception as e:
        raise IOError(f"Error creating project structure: {e}")


def find_project_dir(start_dir: Optional[str] = None) -> str:
    """Find novel project directory by looking for state.json.
    
    Searches current directory and parent directories up to 3 levels.
    
    Args:
        start_dir: Directory to start search (default: current dir)
        
    Returns:
        Path to project directory
        
    Raises:
        ValueError: If no project found
    """
    if start_dir is None:
        start_dir = os.getcwd()
    
    start_dir = os.path.abspath(start_dir)
    
    # Check current directory
    if os.path.exists(os.path.join(start_dir, 'state.json')):
        return start_dir
    
    # Check parent directories (up to 3 levels)
    current = start_dir
    for _ in range(3):
        parent = os.path.dirname(current)
        if parent == current:  # Reached root
            break
        
        if os.path.exists(os.path.join(parent, 'state.json')):
            return parent
        
        current = parent
    
    raise ValueError(
        "No novel project found. Run 'novel new <name>' to create one, "
        "or use --project flag to specify path."
    )


def load_project_state(project_dir: str) -> dict:
    """Load project state from state.json.
    
    Args:
        project_dir: Path to project directory
        
    Returns:
        State dictionary
        
    Raises:
        FileNotFoundError: If state.json doesn't exist
        ValueError: If state.json is invalid
    """
    state_path = os.path.join(project_dir, 'state.json')
    return read_json(state_path)


def save_project_state(project_dir: str, state: dict):
    """Save project state to state.json.
    
    Args:
        project_dir: Path to project directory
        state: State dictionary to save
        
    Raises:
        IOError: If state cannot be saved
    """
    state['last_updated'] = datetime.now().isoformat()
    state_path = os.path.join(project_dir, 'state.json')
    write_json(state_path, state)


def get_project_config(project_dir: str) -> Config:
    """Load project-specific configuration.
    
    Args:
        project_dir: Path to project directory
        
    Returns:
        Config object with project settings
    """
    config_path = os.path.join(project_dir, 'config.yaml')
    return Config(config_path if os.path.exists(config_path) else None)
